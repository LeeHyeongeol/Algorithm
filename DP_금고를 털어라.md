# 🔒 문제

자신이 감옥에 간 사이 연인이었던 줄리아를 앤디에게 빼앗겨 화가 난 조지는 브레드, 맷과 함께 앤디 소유의 카지노 지하에 있는 금고를 털기로 합니다. 온갖 트랩을 뚫고 드디어 금고에 진입한 조지와 일행들. 조지는 이와중에 감옥에서 틈틈이 공부한 알고리즘을 이용해 target 금액을 훔칠 수 있는 방법의 경우의 수를 계산하기 시작합니다.

예를 들어 $50 을 훔칠 때 $10, $20, $50 이 있다면 다음과 같이 4 가지 방법으로 $50을 훔칠 수 있습니다.

$50 한 장을 훔친다
$20 두 장, $10 한 장을 훔친다
$20 한 장, $10 세 장을 훔친다
$10 다섯 장을 훔친다
훔치고 싶은 target 금액과 금고에 있는 돈의 종류 type 을 입력받아, 조지가 target 을 훔칠 수 있는 방법의 수를 리턴하세요.

# 🔒 인자

인자 1: target
Number 타입의 100,000 이하의 자연수
인자 2: type
Number 타입을 요소로 갖는 100 이하의 자연수를 담은 배열

# 🔒 출력

Number 타입을 리턴해야 합니다.
조지가 target을 훔칠 수 있는 방법의 수를 숫자로 반환합니다.

# 🔒 주의사항

모든 화폐는 무한하게 있다고 가정합니다.

# 🔒 입출력 예시
```jsx
let output = ocean(50, [10, 20, 50]);
console.log(output); // 4

let output = ocean(100, [10, 20, 50]);
console.log(output); // 10

let output = ocean(30, [5, 6, 7]);
console.log(output); // 4
```

# 💡 생각

동적 프로그래밍은 이미 연산된 결과를 담아두고 필요할 때 꺼내 쓸 수 있는 방법이다.
피보나치의 DP 풀이법을 생각했을 때 50원을 훔치기 위한 모든 경우의 수는 50원을 훔치기 위한 하위 경우의 수를 모두 더해나가야 하므로
빈 배열에 훔칠 금액의 경우의 수를 저장하고 출력하면 될 것 같다.


# ✍ 풀이

```jsx
function ocean(target, type) {
  // TODO: 여기에 코드를 작성합니다.
  //50원 만드는 법이면 [0,0,0,...,0]
  //배열의 인덱스가 목표금액의 target
  let arr = new Array(target + 1).fill(0)
  arr[0] = 1
  //화폐 종류에 따른 반복문
  type.map(el => {
    //일단 i를 넣고 (type별 경우의 수 무조건 1 증가)
    arr[el] += 1
    //다음 인덱스에 이전 경우의 수 + 경우의 수
    for (let i = el + 1; i <= target; i++) {
      arr[i] += arr[i - el]
    }
  })
  return arr[target]
}
```
# 💡 후기
아예 이해를 못해서 막막했었다.
유튜브 강의를 보면서 피보나치의 예를 이 문제에 적용해보려고 생각했다.
50원을 훔칠 수 있는 경우는 여러 조합이 있다.
그 조합안에 요소를 조합하는 방법도 여러가지다.
그 방법들을 배열에 저장해두고 필요할 때 꺼내쓰는 것이 동적 프로그래밍이라는 것을 알게 됐다.
